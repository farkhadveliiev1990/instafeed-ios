//
//  ProfileViewController.swift
//  Instafeed
//
//  Created by A1GEISP7 on 07/09/19.
//  Copyright (c) 2019 gulam ali. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import SkyFloatingLabelTextField
import SDWebImage

protocol ProfileDisplayLogic: class
{
  func displayProfileData(viewModel: Profile.ProfileData.ViewModel)
    func displayProfileUpdationResult(viewModel: Profile.ProfileData.ViewModel)
    func displayProfilePicRemovalResult(viewModel: Profile.ProfileData.ViewModel)
    func displayProfilePicUpdationResult(viewModel: Profile.ProfileData.ViewModel)
}

class ProfileViewController: UIViewController, ProfileDisplayLogic
{
    var interactor: ProfileBusinessLogic?
    var router: (NSObjectProtocol & ProfileRoutingLogic & ProfileDataPassing)?
    var profileData = Profiledata()
    
    @IBOutlet weak var profilePic: UIImageView!
    @IBOutlet weak var btnEdit: UIButton!
    @IBOutlet weak var txtFieldFullName: SkyFloatingLabelTextField!
    @IBOutlet weak var txtFieldDOB: SkyFloatingLabelTextField!
    @IBOutlet weak var txtFieldAddress1: SkyFloatingLabelTextField!
    @IBOutlet weak var txtFieldAddress2: SkyFloatingLabelTextField!
    @IBOutlet weak var txtFieldCountry: SkyFloatingLabelTextField!
    @IBOutlet weak var txtFieldCity: SkyFloatingLabelTextField!
    @IBOutlet weak var txtPinCOde: SkyFloatingLabelTextField!
    @IBOutlet weak var txtFieldUsername: SkyFloatingLabelTextField!
    
    @IBOutlet weak var btnMale: UIButton!
    @IBOutlet weak var btnFemale: UIButton!
    @IBOutlet weak var txtFieldAccountName: SkyFloatingLabelTextField!
    @IBOutlet weak var txtAccountNumber: SkyFloatingLabelTextField!
    @IBOutlet weak var txtFieldIfscCode: SkyFloatingLabelTextField!
    @IBOutlet weak var btnSavingAccount: UIButton!
    @IBOutlet weak var btnCurrentAccount: UIButton!
    @IBOutlet weak var txtFieldMobile: SkyFloatingLabelTextField!
    @IBOutlet weak var lblInviteShare: UILabel!

    @IBOutlet weak var nameUL: UILabel!
    
    // MARK: Object lifecycle
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)
    {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder)
    {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: Setup
    
    private func setup()
    {
        let viewController = self
        let interactor = ProfileInteractor()
        let presenter = ProfilePresenter()
        let router = ProfileRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
    
    // MARK: View lifecycle
    
    override func viewDidLoad()
    {
        super.viewDidLoad()
        let toolBar = UIToolbar().ToolbarPiker(mySelect: #selector(ProfileViewController.dismissPicker))
        
        let datePickerView = UIDatePicker()
        datePickerView.datePickerMode = .date
        datePickerView.maximumDate = Date()
        
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd"
        let defaultDate = dateFormatter.string(from: Date())
        txtFieldDOB.text = defaultDate
        
        txtFieldDOB.inputView = datePickerView
        datePickerView.addTarget(self, action: #selector(self.handleDatePicker(_:)), for: .valueChanged)
        
        txtFieldDOB.inputAccessoryView = toolBar
        self.lblInviteShare.text = "Share Your Invite Code - 13318"
        enableUserInteractionToElements()
        self.profilePic.layer.cornerRadius = (85/2)
        self.profilePic.clipsToBounds = true
        fetchData()
    }
    
    @objc func dismissPicker() {
        view.endEditing(true)
    }
    
    @objc func handleDatePicker(_ sender: UIDatePicker) {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd"
        self.profileData.birth_date = dateFormatter.string(from: sender.date)
        txtFieldDOB.text = dateFormatter.string(from: sender.date)
    }
    
    func fetchData()
    {
        let request = Profile.ProfileData.Request()
        interactor?.getProfile(request: request)
    }
    
    func removeProfilePic(){
        if profilePic.image == UIImage(named: "proo"){
            Toast().showToast(message: "Please add profile picture first.", duration: 2)
        }else{
            let request = Profile.ProfileData.Request()
            interactor?.removeProfilePic(request: request)
        }
    }
    func changeProfilePic(image:UIImage){
        var request = Profile.ProfileData.Request()
        request.profilePic = image
        interactor?.updateProfilePic(request: request)
    }
    
    
    func displayProfileData(viewModel: Profile.ProfileData.ViewModel)
    {
        self.profileData = viewModel.data
        
        if let firstName = viewModel.profileData.first_name{
            txtFieldFullName.text = firstName
            
            nameUL.text = firstName
        }
        
        if let userName = viewModel.profileData.username{
            txtFieldUsername.text = userName
        }
        
        let placeholder = UIImage(named: "proo")
        if let profilephoto = UserDefaults.standard.value(forKey: "ProfileImage") as? String{
            let url = URL(string: profilephoto)
            self.profilePic?.sd_setImage(with: url, placeholderImage: placeholder, options: .progressiveLoad, context: nil)
        }else{
            self.profilePic?.image = placeholder
        }
        
        
        
        if let dateOfBirth = viewModel.profileData.birth_date, !dateOfBirth.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty{
            txtFieldDOB.text = dateOfBirth
        }
        
        if let address = viewModel.profileData.address, !address.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty{
            txtFieldAddress1.text = address
        }
        if let city = viewModel.profileData.city, !city.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty{
            txtFieldCity.text = city
        }
        if let pinCode = viewModel.profileData.pincode, !pinCode.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty{
            txtPinCOde.text = pinCode
        }
        
        if let mobile = viewModel.profileData.phone, !mobile.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty{
            txtFieldMobile.text = mobile
        }
        
        if let gender = viewModel.profileData.sex, !gender.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty{
            if gender == "F"{
                setGender(male: false)
            }else{
                setGender()
            }
        }
        
        if let accountName = viewModel.profileData.bank_name, !accountName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty{
            txtFieldAccountName.text = accountName
        }
        if let accountNumber = viewModel.profileData.bank_acc_no, !accountNumber.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty{
            txtAccountNumber.text = accountNumber
        }
        if let ifscCode = viewModel.profileData.bank_ifsc_code, !ifscCode.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty{
            txtFieldIfscCode.text = ifscCode
        }
        if let accountType = viewModel.profileData.bank_acc_type, !accountType.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty{
            if accountType == "Saving" || accountType == "saving"{
                setAccountType()
            }else{
                setAccountType(isSavingAccount: false)
            }
        }
    }
    
    func displayProfileUpdationResult(viewModel: Profile.ProfileData.ViewModel) {
        if let message = viewModel.result.message{
            if message == "Profile successfully updated."{
                enableUserInteractionToElements(isEnabled: !btnEdit.isSelected)
                Toast().showToast(message: message, duration: 2)
            }else{
                Toast().showToast(message: "Something went wrong. Please try again later!!!", duration: 2)
            }
        }
        
    }
    
    func displayProfilePicRemovalResult(viewModel: Profile.ProfileData.ViewModel) {
        if let message = viewModel.removePicResult.message{
            if message == "Profile successfully updated."{
                self.profilePic.image = UIImage(named: "proo")
                Toast().showToast(message: message, duration: 2)
            }else{
                Toast().showToast(message: "Something went wrong. Please try again later!!!", duration: 2)
            }
        }
    }
    
    func displayProfilePicUpdationResult(viewModel: Profile.ProfileData.ViewModel) {
        if let message = viewModel.updatedProfilePicResult.message{
            if message == "Profile pic successfully updated."{
                self.profilePic.image = viewModel.updatedProfilePicResult.image
                Toast().showToast(message: message, duration: 2)
            }else{
                Toast().showToast(message: "Something went wrong. Please try again later!!!", duration: 2)
            }
        }
    }
    
    func enableUserInteractionToElements(isEnabled:Bool = false){
        txtFieldFullName.isUserInteractionEnabled = isEnabled
        txtFieldUsername.isUserInteractionEnabled = isEnabled
        txtFieldDOB.isUserInteractionEnabled = isEnabled
        txtFieldAddress1.isUserInteractionEnabled = isEnabled
        txtFieldAddress2.isUserInteractionEnabled = isEnabled
//        txtFieldCountry.isUserInteractionEnabled = isEnabled
        txtFieldCity.isUserInteractionEnabled = isEnabled
        txtPinCOde.isUserInteractionEnabled = isEnabled
        btnMale.isUserInteractionEnabled = isEnabled
        btnFemale.isUserInteractionEnabled = isEnabled
        txtFieldAccountName.isUserInteractionEnabled = isEnabled
        txtAccountNumber.isUserInteractionEnabled = isEnabled
        txtFieldIfscCode.isUserInteractionEnabled = isEnabled
        btnSavingAccount.isUserInteractionEnabled = isEnabled
        btnCurrentAccount.isUserInteractionEnabled = isEnabled
        btnEdit.isSelected = isEnabled
        btnEdit.setTitle(isEnabled ? "Save" : "Edit" , for: .normal)
        txtFieldMobile.isUserInteractionEnabled = isEnabled
    }
    
    func setGender(male:Bool = true){
        btnMale.isSelected = male
        btnFemale.isSelected = !male
        btnFemale.setImage(btnFemale.isSelected ? UIImage(named: "radio-icon") : UIImage(named: "outlined-icon"), for: .normal)
        btnMale.setImage(btnMale.isSelected ? UIImage(named: "radio-icon") : UIImage(named: "outlined-icon"), for: .normal)
        self.profileData.sex = male ? "M" : "F"
    }
    
    func setAccountType(isSavingAccount:Bool = true){
        btnSavingAccount.isSelected = isSavingAccount
        btnCurrentAccount.isSelected = !isSavingAccount
        btnSavingAccount.setImage(btnSavingAccount.isSelected ? UIImage(named: "radio-icon") : UIImage(named: "outlined-icon"), for: .normal)
        btnCurrentAccount.setImage(btnCurrentAccount.isSelected ? UIImage(named: "radio-icon") : UIImage(named: "outlined-icon"), for: .normal)
        self.profileData.bank_acc_type = isSavingAccount ? "Saving" : "Current"
    }
    
    func callPhotosSheeet(){
        CommonFuncs.HitactionSheet(vc: self, title1: "Camera", title1action: {
            self.clickimage()
        }, title2: "Photos") {
            self.pickimage()
        }
    }
    
    //MARK:>>>> Picking Image from Gallery
    func pickimage(){
        if UIImagePickerController.isSourceTypeAvailable(.photoLibrary){
            let controller = UIImagePickerController()
            controller.delegate = self
            controller.sourceType = .photoLibrary
            controller.allowsEditing = false
            present(controller, animated: true, completion: nil)
        }
    }
    
    //MARK:>>>> Picking Image from Camera
    
    func clickimage(){
        if UIImagePickerController.isSourceTypeAvailable(.camera) {
            let controller = UIImagePickerController()
            controller.delegate = self
            controller.sourceType = .camera
            controller.allowsEditing = false
            self.present(controller, animated: true, completion: nil)
        }else{
            print("You Dont have a CAMERA")
        }
    }
    
    //MARK:- Button Action Handler
    @IBAction func btnBackAction(_ sender: UIButton) {
        self.dismiss(animated: true, completion: nil)
    }
    
    @IBAction func btnChangeProfilePicAction(_ sender: UIButton) {
        let alertController = UIAlertController(title: nil, message: "", preferredStyle: .actionSheet)
        
        let defaultAction = UIAlertAction(title: "Change Profile Pic", style: .default, handler: { (alert: UIAlertAction!) -> Void in
            self.callPhotosSheeet()
        })
        
        let deleteAction = UIAlertAction(title: "Delete ", style: .destructive, handler: { (alert: UIAlertAction!) -> Void in
            self.removeProfilePic()
        })
        
        let cancelAction = UIAlertAction(title: "Cancel", style: .cancel, handler: { (alert: UIAlertAction!) -> Void in
            //  Do something here upon cancellation.
        })
        
        alertController.addAction(defaultAction)
        alertController.addAction(deleteAction)
        alertController.addAction(cancelAction)
        
        self.present(alertController, animated: true, completion: nil)
    }
    
    @IBAction func btnSharection(_ sender: UIButton) {
        var txt = "Join Instafeed, earn Cash and Reward Points \n\nUse referral code: 13318\n\nDownload app for more updates\nhttps://bit.ly/2pDJWrB"
        
        let imageToShare = [ txt ]
        let activityViewController = UIActivityViewController(activityItems: imageToShare, applicationActivities: nil)
        activityViewController.popoverPresentationController?.sourceView = self.view // so that iPads won't crash
        
        // exclude some activity types from the list (optional)
        activityViewController.excludedActivityTypes = [ UIActivity.ActivityType.airDrop ]
        
        // present the view controller
        self.present(activityViewController, animated: true, completion: nil)
        
    }

    
    
    @IBAction func btnEditAction(_ sender: UIButton) {
        if btnEdit.isSelected {
            self.view.endEditing(true)
            let deadlineTime = DispatchTime.now() + .seconds(1)
            DispatchQueue.main.asyncAfter(deadline: deadlineTime, execute: {
                var request = Profile.ProfileData.Request()
                request.data = self.profileData
                self.interactor?.updateProfile(request:request)
            })
        }else{
            enableUserInteractionToElements(isEnabled: !btnEdit.isSelected)
        }
    }
    
    @IBAction func btnMaleAction(_ sender: UIButton) {
        setGender()
    }
    
    @IBAction func btnFemaleAction(_ sender: UIButton) {
        setGender(male: false)
    }
    
    @IBAction func btnSavingAccountAction(_ sender: UIButton){
        setAccountType()
    }
    
    @IBAction func btnCurrentAccountAction(_ sender: UIButton) {
        setAccountType(isSavingAccount: false)
    }
}
extension ProfileViewController : UITextFieldDelegate{
    
    func textFieldDidEndEditing(_ textField: UITextField) {
        if textField == self.txtFieldFullName{
            self.profileData.first_name = self.txtFieldFullName.text!
        }else if textField == self.txtFieldUsername{
            self.profileData.username = self.txtFieldUsername.text!
        }else if textField == self.txtFieldDOB{
            self.profileData.birth_date = self.txtFieldDOB.text!
        }else if textField == self.txtFieldAddress1{
            self.profileData.address = self.txtFieldAddress1.text!
        }else if textField == self.txtFieldCountry{
            //self.profileData. = self.txtFieldCountry.text
        }else if textField == self.txtFieldCity{
            self.profileData.city = self.txtFieldCity.text!
        }else if textField == self.txtPinCOde{
            self.profileData.pincode = self.txtPinCOde.text!
        }else if textField == self.txtAccountNumber{
            self.profileData.bank_acc_no = self.txtAccountNumber.text!
        }else if textField == self.txtFieldAccountName{
            self.profileData.bank_name = self.txtFieldAccountName.text!
        }else if textField == self.txtFieldIfscCode{
            self.profileData.bank_ifsc_code = self.txtFieldIfscCode.text!
        }else if textField == self.txtFieldMobile{
            self.profileData.phone = self.txtFieldMobile.text!
        }
    }
}
extension ProfileViewController: UIImagePickerControllerDelegate & UINavigationControllerDelegate{
    func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {
        dismiss(animated: true, completion: nil)
    }
    
    func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
        guard let image = info[.originalImage] as? UIImage else {
            fatalError("Expected a dictionary containing an image, but was provided the following: \(info)")
        }
        
        if let resizeimage = image.resizedTo1MB(){
            dismiss(animated: true, completion: {
                self.changeProfilePic(image: resizeimage)
            })
        }
    }
}
extension UIToolbar {
    
    func ToolbarPiker(mySelect : Selector) -> UIToolbar {
        
        let toolBar = UIToolbar()
        
        toolBar.barStyle = UIBarStyle.default
        toolBar.isTranslucent = true
        toolBar.tintColor = UIColor.black
        toolBar.sizeToFit()
        
        let doneButton = UIBarButtonItem(title: "Done", style: UIBarButtonItem.Style.plain, target: self, action: mySelect)
        let spaceButton = UIBarButtonItem(barButtonSystemItem: UIBarButtonItem.SystemItem.flexibleSpace, target: nil, action: nil)
        
        toolBar.setItems([ spaceButton, doneButton], animated: false)
        toolBar.isUserInteractionEnabled = true
        
        return toolBar
    }
    
}
